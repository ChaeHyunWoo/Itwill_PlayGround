SELECT * FROM TAB;

--모든데이터 가져오기
/* 범위 주석 */
SELECT * FROM CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND(PAY, -4) PAY FROM COMPANY;

SELECT * FROM CUSTOM;

--770322-1****** --주민번호 뽑기
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;


SELECT COUNT(*) INWON FROM CUSTOM
WHERE JOB = '회사원'; -- 177

SELECT COUNT(*) INWON FROM CUSTOM
WHERE SCHOL = '대졸'; -- 43

SELECT COUNT(*) INWON FROM CUSTOM
WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM
WHERE POINT >= 200;


--테이블의 이름과 컬럼의 이름은 중복되면 안된다.
SELECT * FROM COMPANY;

--포지션이 대리인 사람은 몇명이냐
SELECT COUNT(PAY) FROM COMPANY
WHERE POSIT = '대리';

--포지션이 대리인 사람이 받는 PAY의 총합?
SELECT SUM(PAY) FROM COMPANY
WHERE POSIT = '대리';


SELECT * FROM CUSTOM;

--직업 별 인원수 구하기
SELECT JOB, COUNT(*) INWON FROM CUSTOM
GROUP BY JOB;

--학력 별 POINT의 평균 구하기
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM
GROUP BY SCHOL;

--지역별 POINT 합계 구하기 -- ""찍은 이유는 MAX랑 MIN이 함수를 인식될까봐 찍음
SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT) "MAX", MIN(POINT) "MIN" FROM CUSTOM
GROUP BY ADDR1;


--성별 나이의 평균, 인원수 구하기
SELECT SEX,ROUND(AVG(AGE))"AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;


SELECT
CASE SEX
WHEN '1' THEN '남자'
WHEN '0' THEN '여자'
END GENDER
, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT"
FROM CUSTOM
GROUP BY SEX;

/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100                          
	WHEN 2 THEN 200                         
	WHEN 3 THEN 300                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT             
FROM DUAL;
*/



SELECT * FROM COMPANY;

--직책별 월급의 합, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT; -- DB에 없는 컬럼으로 만들어서 이 테이플은 파생 테이블이다.


--직책별 월급의 합, 평균, MAX, MIN (HAVING 사용하기)
--ORDER BY는 별칭을 써도 정렬되지만 나머지는 안된다. 
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT 
HAVING COUNT(*) > 60;

--------------------1월 25일 --------------------------------------------------------------------------------------------

--JOIN문
/*
EQUI JOIN(INNER JOIN)
NON-EQUI JOIN -- 이건 오라클에만 존재.
OUTER JOIN
CROSS JOIN -- 사용 거의 안함
SELF JOIN
INNER(EQUI)는 90%  SELF 는 10% 이 2개는 많이 사용함
*/


--EQUI JOIN(INNER JOIN) -- 오라클 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B --컬럼명에는 AS를 써서 별칭을 쓰지만 테이블 별칭은 AS 쓰면 X
WHERE A.USERID = B.USERID;

--INNER JOIN - 표준 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B  -- INNER를 생략하고 해도 문제 없음
ON A.USERID = B.USERID;

--테이블 'CUSTOM'에서 UserID, UserName을 검색하고
--POINT 테이블에서 제품 구입, 로그인에 관계된 POINT 점수(Product, Login)를 검색
SELECT * FROM POINT;

--EQUI JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

--INNER JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN  --위와 동일 결과
FROM CUSTOM A INNER JOIN POINT B -- INNER 생략가능
ON A.USERID = B.USERID -- AND LOGIN >= 10; -> 여기다 써도 되고
WHERE LOGIN >= 10; -- 여기다 써도 된다.




--OUTER JOIN(외부 조인)
--특정 테이블이 기준이되서 데이터를 찾아옴. ( 자주 사용X 그래도 기본은 알고있어야함)

SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
WHERE A.USERID = B.USERID(+);

--위를 ANSI표준으로 만들면(위와 같음)
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
ON A.USERID = B.USERID(+);

-------------------------------------------------------------------------
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
WHERE A.USERID(+) = B.USERID;

--위를 ANSI 표준으로 만들면
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
ON A.USERID(+) = B.USERID;


SELECT * FROM RESEARCH;

SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID 
WHERE ANSWER IS NULL;

-----------여기까지가 OUTER JOIN---------------------------------------------------------


--CROSS JOIN(상호 조인)
SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; -- 464



SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT 
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID; -- CROSS JOIN은 INNER JOIN에서 이 줄을 빼면 된다.



-- SELF JOIN

SELECT * FROM CUSTOM;

DESC CUSTOM;

--동명이인 잡아내는 공식
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID -- A.USERID와 B.USERID가 틀려야함
ORDER BY A.USERNAME;


-- 'CUSTOM' 테이블에서 '제주도'에 살고 있는 사람 중에 동일한 이름을 갖는 행을 검색

SELECT * FROM CUSTOM WHERE ADDR1 = '제주도'; -- 14명나옴


SELECT DISTINCT A.* -- 제주도에 사는 사람이 동명 3인이상이면 DISTINCT를 써준다. 2인까지는 안써도된다.
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;



SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;

SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT * FROM CUSTOM;


CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT * FROM JEJU;


CREATE TABLE KYUNG
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

SELECT * FROM KYUNG;


CREATE TABLE SEOUL
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

SELECT * FROM SEOUL;

----------------
SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;




--  SUB-QUERY(하위쿼리) : 쿼리 안에 쿼리를 넣는다.          - 하위 쿼리는 반드시 괄호로 묶어줘야한다.

-- 'COMPANY' 테이블에서 UserID, Company, Dept, Pay와 평균 월급을 검색
SELECT USERID, COMPANY, DEPT, PAY AVG(PAY)FROM COMPANY; -- X 에러남 해결방법은 아래


SELECT ROUND(AVG(PAY)) FROM COMPANY;

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY; -- 이렇게 하면 값을 받기위해 2번을 실행하니 이렇게 하면 X


--정석 방법
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY, --하위쿼리는 연산 가능
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) 차액
FROM COMPANY;

--'CUSTOM' 테이블에서 평균 나이 이상인 행들을 검색하시오.

SELECT AVG(AGE) FROM CUSTOM;

SELECT * FROM CUSTOM WHERE AGE>= 28;


--->
SELECT * FROM CUSTOM WHERE AGE>= (SELECT AVG(AGE) FROM CUSTOM);

--'COMPANY' 테이블에서 평균 월급보다 적은 월급을 받는 행을 검색

SELECT * FROM COMPANY 
WHERE  PAY < (SELECT AVG(PAY) FROM COMPANY);


-- '현대자동차' 회사에 근무하는 고객의 UserID, UserName, Addr1, Schol 열을 검색

SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224', 'el3409');
--WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');


--JOIN문으로 바꿔서 하면 ( 하위 쿼리는 JOIN문으로 바꿔서 할 수 있다.)
--SELECT A. *, COMPANY
SELECT A.USERID,USERNAME, ADDR1,SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID AND COMPANY LIKE '현대자동차%';


--SALSE 테이블에서 4회 이상 판매 기록이 있는 고객들의 기본 정보를 검색

SELECT * FROM SALES -- SALES테이블
ORDER BY USERID;



--SALES 테이블에서 4회 이상 판매 기록이 있는 고객
SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;


SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--> JOIN문으로 바꾸면

--INLINE VIEW
SELECT A.*,CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4) B
WHERE A.USERID = B.USERID;

/*
SELECT A.*
FROM () A, () B
WHERE A.USERID = B.USERID;
*/



-- 총 판매 금액이 100만원 이상인 'CUSTOM' 테이블에는 고객의 기본 정보

--먼저 100만원 이상인 사람 찾기
SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000;



--하위 쿼리
SELECT * FROM CUSTOM
WHERE USERID IN 
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000);

--JOIN

SELECT A.*, CNT, HAP
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;


--ANY, ALL

--ANY는 범위값을 무조건 포함하고 있어야하고, ALL은 범위값을 포함 X

SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도' ORDER BY POINT;

/*
132 ~ 269
>ANY : 132보다 큰 데이터
<ANY : 269보다 작은 데이터
>ALL : 269보다 큰 데이터
<ANY : 132보다 작은 데이터
*/

--ANY가 MIN보다 연산속도가 훨씬 빠르다.
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------


SELECT * FROM CUSTOM WHERE POINT = 131;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';


--------------------------------------------------------------------------------
-- IN과 =ANY 연산자는 같다
--현대자동차에 근무하는 사람은?

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID = ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <> ALL (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
--여기를 하단 상관 쿼리로 바꿈
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관 쿼리(눈도장만 찍어놓기) - EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--------------------------------------------------------------------------------
--상관 쿼리(눈도장만 찍어놓기) - NOT EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--상관쿼리는 독자적으로 실행X

--------------------------------------------------------------------------------
--경기도에 살면서 나이가 20보다 작은 사람
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;


SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A;

--위와 다른방법
SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A
WHERE A.AGE<=20;


---------------------------------------------------@@@@@@@@@@@@@  2월 3일  @@@@@@@@@@@@@@------------------------------------------------------------------



create table 사원
(사원번호 number(10),
사원명 varchar2(10),
부서번호 number(2),
직급 varchar2(10),
우편번호 char(7),
주소 varchar2(50),
전화번호 char(15),
급여 number(5),
커미션 number(5),
입사일 date,
성별 char(6),
사수번호 number(10)
);


insert into 사원 values(2001,'이순신',10,'부장','125-365','서울 용산구','02-985-1254',3500,100,'1980-12-01','남자',null);
insert into 사원 values(2002,'홍길동',10,'대리','354-865','서울 강남구','02-865-1254',4000,'','2000-01-25','남자',2004);
insert into 사원 values(2003,'성유리',20,'사원','587-456','부산 해운대구','051-256-9874',2500,100,'2002-05-24','여자',2002);
insert into 사원 values(2004,'옥주현',30,'과장','987-452','서울 강남구','02-33-6589',5000,'','1997-03-22','여자',2001);
insert into 사원 values(2005,'길건',10,'대리','123-322','서울 성동구','02-888-9564',3000,100,'1999-07-15','여자',2004);
insert into 사원 values(2006,'한지혜',20,'사원','154-762','서울 송파구','02-3369-9874',2000,'','2003-05-22','여자',2005);
insert into 사원 values(2007,'박솔미',30,'대리','367-985','서울 영등포구','02-451-2563',3000,100,'2006-01-25','여자',2004);
insert into 사원 values(2008,'이효리',40,'사원','552-126','서울 중구','02-447-3256',2000,'','2001-02-02','여자',2007);

select * from 사원;
DESC 사원; --사원 테이블의 자료형이 나옴
commit;

-----------------------------------------이게 PL SQL이다.

--Anonymous

DECLARE --이름없는 PROCEDURE
TYPE FIRSTTYPE IS RECORD
--(A VARCHAR2, B VARCHAR2, C NUMBER); -- 이렇게 써도 되지만 
(A 사원.사원명%TYPE,B 사원.직급%TYPE, C 사원.급여%TYPE); -- 좀더 쉽게 쓸수 있다 

CUS FIRSTTYPE;--CUS라는 변수를 선언하고 FORSTTYPE레코드 저장공간을 생성해서 CUS에 넣는다   -> 자바에서 객체 생성 개념과 동일함.

BEGIN --문으로 시작하고 
SELECT 사원명,직급,급여 INTO CUS FROM 사원 WHERE 사원번호=2001;--사원명 직급 급여 INTO해서 CUS에 넣는다 

DBMS_OUTPUT.PUT_LINE('--------------------------');
DBMS_OUTPUT.PUT_LINE('사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE(CUS.A||'  '||CUS.B||'  '||TO_CHAR(CUS.C));--급여가 숫자라서 문자로 변형
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정은 '||USER||'입니다'); --USER는 시스템 변수
DBMS_OUTPUT.PUT_LINE('현재 질의한 시간은 '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MM:SS'));--SYDATE를 읽어와서 내가 원하는 입맛으로 표현한다 
END;--끝난다
--------------------------------------------------------------------------------------------------
DECLARE
SAWON_RECORD 사원%ROWTYPE; -- 전체 컬럼의 데이터 타입을 읽어와야 할 때 사용 / 사원 테이블의 행 TYPE를 모두 읽어와라
BEGIN
SELECT * INTO SAWON_RECORD FROM 사원 WHERE 사원번호=2002;
DBMS_OUTPUT.PUT_LINE('사원번호: '|| SAWON_RECORD.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명: '|| SAWON_RECORD.사원명);
DBMS_OUTPUT.PUT_LINE('직급: '|| SAWON_RECORD.직급);
DBMS_OUTPUT.PUT_LINE('주소: '|| SAWON_RECORD.주소);
DBMS_OUTPUT.PUT_LINE('입사일: '|| SAWON_RECORD.입사일);
END;

--익명의 프로시져 반복문 사용
DECLARE
TYPE SANAME_TYPE IS TABLE OF 사원.사원명%TYPE -- 사원명으로 만들 데이터타입을 SANAME_TABLE_TYPE에 저장
INDEX BY BINARY_INTEGER;

TYPE JIK_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

SANAME_COL SANAME_TYPE;--컬럼 선언
JIK_COL JIK_TYPE;

I BINARY_INTEGER := 0; -- 정수형 변수 I 선언
 
BEGIN

FOR K IN (SELECT 사원명, 직급 FROM 사원) LOOP -- FOR문 시작 / K는 변수
I := I + 1;
SANAME_COL(I) := K.사원명;
JIK_COL(I) := k.직급;
END LOOP; --FOR문 종료

DBMS_OUTPUT.PUT_LINE('사원명 직급');
DBMS_OUTPUT.PUT_LINE('-----------');

FOR J IN 1..I LOOP--1부터 I까지 (자바의 확장 FOR문과 유사함)
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J), 12) || RPAD(JIK_COL(J), 9));
END LOOP;

END;--BEGIN의 END
--DECLARE는 한번 실행하면 사라지기 때문에 따로 파일로 저장해두고 필요시에 복사해 사용한다

-------------------------------------------------------------------------------------------

--저장 PROCEDURE(기본적으로 가장 많이 사용하는 프로시저)

CREATE OR REPLACE PROCEDURE CHANGE_PAY
(V_SANO IN NUMBER, V_NEW_PAY IN NUMBER) -- 이름을 호출하면서 사용하는 매개변수 작성
IS 
BEGIN -- BEGIN문에서 내부적으로 사용하는 변수 작성 시 IS 뒤에 작성
UPDATE 사원 SET 급여 = V_NEW_PAY WHERE 사원번호 = V_SANO; --EXEC CHANGE_PAY(2001, 5000);
COMMIT; -- UPDATE문을 실행한 뒤 COMMIT을 해줘야 변경 내용이 저장된다.
END CHANGE_PAY; -- CHANGE_PAY 프로시저명 생략하고 END; 만 써도 된다.

--PROCEDURE의 이름을 쓰거나 안써도된다.

--IS 위에 쓰는 변수는 매개변수.
--IS 아래 쓰는 변수는 내부에서 사용하는 변수.지역변수.
--IN :외부에서 받아내는 값을 의미. 생략가능.매개변수
--OUT :외부로 내보내주는 값.

EXEC CHANGE_PAY(2001, 5000); -- 프로시저 실행 / UPDATE이므로 한번 실행하고 끝.
SELECT * FROM 사원 WHERE 사원번호 = '2001'; -- 변경 내용 확인 가능

EXEC CHANGE_PAY(2002, 3000);
SELECT * FROM 사원 WHERE 사원번호 = '2005';


-------함수 만들기
CREATE OR REPLACE FUNCTION F_TAX
(V_SANO IN NUMBER)
RETURN NUMBER -- RETURN(리턴)값은 세미콜론 ; 이 없음
IS
V_TAX NUMBER; -- 내부 변수 선언

--함수 실행
BEGIN
SELECT ((급여*12) + NVL(커미션, 0))*0.05 INTO V_TAX
FROM 사원 WHERE 사원번호 = V_SANO; --여기까지

RETURN V_TAX;
END F_TAX;
--------------------------------------------------------------------------------------------------
SELECT * FROM 사원;

SELECT 사원번호,사원명,직급,급여,커미션,F_TAX(2001) TAX FROM 사원 -- 함수부분 CMD캡처한걸 여기서 실행
WHERE 사원번호=2001;

--지금부터하는 코딩은  SCRIPT(파일)로 저장한다
SET SERVEROUTPUT ON
SET VERIFY OFF -- 변수의 값이 변경된 내용을 보여주는 명령어

ACCEPT ID PROMPT '검색할 아이디를 입력하세요: ';--ID는 사용자정의 변수

DECLARE

TYPE GOGAK IS RECORD --GOGAK이라는 데이터타입(RECORD)를 만듬
(A CUSTOM.USERID%TYPE, --A라는 변수를 만들고 
B CUSTOM.USERNAME%TYPE,
C NUMBER(12,2),
D NUMBER(5));

CUS GOGAK; -- CUS는 A,B,C,D 4개의 변수를 저장할 수 있는 레코드

BEGIN
SELECT C.USERID, C.USERNAME, S.합계, S.구입횟수 INTO CUS
FROM CUSTOM C, --CUSTOM를 C라 하고
(SELECT USERID, SUM(PRICE) 합계, COUNT(*) 구입횟수
FROM SALES
GROUP BY USERID) S --이 괄호를 S로 만듬
WHERE C.USERID = S.USERID AND C.USERID ='&ID';--ACCEPT에서 받은 입력값이 &ID로 할당 된다.

DBMS_OUTPUT.PUT_LINE('아이디: '||CUS.A);
DBMS_OUTPUT.PUT_LINE('이  름: '||CUS.B);
DBMS_OUTPUT.PUT_LINE('판매액: '||CUS.C);
DBMS_OUTPUT.PUT_LINE('금  액: '||CUS.D);

END;
/

SELECT * FROM CUSTOM;


--직책을 입력 받아 그 직책의 급여의 총액,평균월급,인원수를 찾으시오

CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS --IS를 기준으로 아래는 블럭 안에서 사용할 변수
A NUMBER;=0;
B NUMBER(12,2);=0; --여긴 자릿값을 줬음
C NUMBER:=0;
BEGIN
SELECT SUM(PAY),AVG(PAY),COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT=JIK;

DMBS_OUTPUT.PUT.LINE('급여총액: '||A||'원');
DMBS_OUTPUT.PUT.LINE('평균월급: '||B||'원');
DMBS_OUTPUT.PUT.LINE('인원수: '||C||'명');
END SEARCHJIK; --END뒤에 SEARCHJIK생략가능
---------------------------------------------------------------

SELECT * FROM COMPANY;

SELECT SUM(PAY),ROUND(AVG(PAY)),COUNT(*)
FROM COMPANY WHERE POSIT=JIK;
GROUP BY POSIT;





--CUSTOM 테이블에 INSERT 시키는 프로시저(CUS_IN)

--프로시저 생성
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,G VARCHAR2,
H VARCHAR2,I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,M NUMBER,N DATE)
IS 
BEGIN 
INSERT INTO CUSTOM VALUES(A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;

--INSERT PROCEDURE를 이용한 데이터 입력
EXEC CUS_IN('A002', 'INNA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);
EXEC CUS_IN('A001', 'SUZI', '123', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);

SELECT * FROM CUSTOM WHERE USERID = 'A002'; -- 조회






--CUSTOM 테이블에 UPDATE 시키는 프로시저(CUS_UP)
CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,
F VARCHAR2,G VARCHAR2,H VARCHAR2,I VARCHAR2,J VARCHAR2,
K VARCHAR2,L VARCHAR2,M NUMBER,N DATE,)
IS
BEGIN
UPDATE CUSTOM SET USERNAME=B, JUMIN=C, AGE=D, SEX=E,
ZIP=F, ADDR1=G, ADDR2=H, ADDR3=I, TEL=J, JOB=K, SCHOL=L,
POINT=M, REGDATE=N
WHERE USERID=A;
COMMIT;
END;

EXEC CUS_IN('A001', 'SUZI', '123', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);






--CUSTOM 테이블에 DELETE 시키는 프로시져(CUS_DEL)
CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS 
BEGIN 
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;

EXEC CUS_DEL('A001');
SELECT * FROM CUSTOM WHERE USERID = 'A001';

---함수

-- 부피를 구하는 함수
CREATE OR REPLACE FUNCTION F_COBVOL
(GILI IN NUMBER, POK IN NUMBER, NOPI IN NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI := GILI*POK*NOPI;
RETURN BUPI;
END;

SELECT F_COBVOL(4, 7, 8) FROM DUAL;

-----
--이름을 입력받아 성을 뺀 이름만 반환
CREATE OR REPLACE FUNCTION F_NAME
(A IN VARCHAR2)
RETURN VARCHAR2
IS
B VARCHAR2(8);
BEGIN
B := SUBSTR(A, -2);
RETURN B;
END;

SELECT USERNAME, F_NAME(USERNAME) 이름 FROM CUSTOM;


SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

COL NAME FORMAT A10;
SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

--SELECT 하는 순간에 폭을 맞춰준다


--사용자에게 입력받아서 출력하기
--입사일(REGDATE)를 입력받아 사원명, 입사일, 근무기간(6년 2RODNJF)을 출력

CREATE OR REPLACE FUNCTION F_SDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE :=
FLOOR(MONTHS_BETWEEN(SYSDATE, V_DATE)/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, V_DATE), 12)) || '개월';
RETURN GUNDATE;
END;
--실행
SELECT USERNAME 사원명, TO_CHAR(REGDATE, 'YYYY-MM-DD')입사일, F_SDAY(REGDATE) 연차 FROM CUSTOM;





COL GUNDATE FORMAT A10;
SELECT USERNAME, REGDATE, F_SDAY(REGDATE) GUNDATE FROM CUSTOM
WHERE ADDR1 = '제주도';


--주민번호를 입력시 성별 변환 해주는 함수
CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(4);
BEGIN
GENDER := SUBSTR(V_JUMIN, 8, 1);


--IN 뒤에 SELECT 또는 직접 문자가 올 수도 있음
IF GENDER IN ('1', '3') THEN
 GENDER := '남';
ELSE
 GENDER := '여';

END IF;
 RETURN GENDER;
END;

--결과 조회
SELECT USERNAME, JUMIN, F_GENDER(JUMIN) GENDER FROM CUSTOM;

COL GENDER FORMAT A10;
SELECT USERNAME, JUMIN, F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE  ADDR1 = '제주도';


--날짜에 년수, 개월수, 날수를 매개변수로 더하는 함수(EX.계약기간)

CREATE OR REPLACE FUNCTION F_GAEYAK
(V_DATE IN DATE, Y IN NUMBER, M IN NUMBER, D IN NUMBER)
RETURN DATE
IS
NALZA DATE;
BEGIN
NALZA := ADD_MONTHS(V_DATE, Y*12);
NALZA := ADD_MONTHS(NALZA, M);
NALZA := NALZA + D;
RETURN NALZA;
END;

--결과 조회
SELECT USERNAME, REGDATE, F_GAEYAK(REGDATE, 1, 11, 29) GAEYAK
FROM CUSTOM WHERE ADDR1 = '제주도';


--몇번째에 오류나는지 확인할때는 CMD에서 SHOW ERRORS

SELECT * FROM CUSTOM;
DESC CUSTOM;



--IF

--급여에 따른 등급 매기기
CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
 RESULT := 'A';
ELSIF V_PAY > 2000000 THEN
 RESULT := 'B';
ELSIF V_PAY > 1500000 THEN
 RESULT := 'C';
ELSIF V_PAY > 1000000 THEN
 RESULT := 'D';
ELSE
 RESULT := 'F';
END IF;
 RETURN RESULT;
END;

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'XA9776';

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'ye8802';

SELECT * FROM COMPANY;



--LOOP--자바에서 DO~WHLE문과 같아

CREATE TABLE LOOP1
(NO NUMBER, NAME VARCHAR2(9) DEFAULT '홍길동');

DECLARE
V_COUNT NUMBER(2) := 1;
BEGIN
LOOP
INSERT INTO LOOP1 (NO) VALUES(V_COUNT);
V_COUNT := V_COUNT + 1;
EXIT WHEN V_COUNT > 10;--빠져나와라~~
END LOOP;
DBMS_OUTPUT.PUT_LINE('데이터 입력 완료!!');
END;

SELECT* FROM LOOP1;



--FOR문
CREATE OR REPLACE PROCEDURE P_FOR
IS
BEGIN
FOR I IN 21..30 LOOP
INSERT INTO LOOP1(NO) VALUES(I);
COMMIT;
END LOOP;
END;

EXEC P_FOR
SELECT * FROM LOOP1;



--WHILE문
CREATE OR REPLACE PROCEDURE BANBOK
(V_LOWER NUMBER, V_UPPER NUMBER) --IN생략
IS
V_COUNTER NUMBER(10) := 0;
V_OUTPUT NUMBER(10) := 0;
BEGIN
V_OUTPUT := V_LOWER;

WHILE V_OUTPUT < V_UPPER LOOP
V_COUNTER := V_COUNTER + 1;
V_OUTPUT := V_OUTPUT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE('최종값은 ' || TO_CHAR(V_OUTPUT) ||'이고'||
'총 반복 횟수는 ' || TO_CHAR(V_COUNTER) || '입니다');
END;

EXEC BANBOK(1, 10);



---DO~WHILE
CREATE OR REPLACE PROCEDURE P_CALC1
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
EXIT WHEN CNT > V_END;
END LOOP;
DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');


--DBMS_OUTPUT.PUT_LINE(V_START ||'부터'|| V_END ||
--'까지의 합은 ' ||TOT|| '입니다');
END;

EXEC P_CALC1(1, 100);



--WHILE
CREATE OR REPLACE PROCEDURE P_CALC2
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC2(1, 100);



--FOR
CREATE OR REPLACE PROCEDURE P_CALC3
(V_START NUMBER, V_END NUMBER)
IS

TOT NUMBER := 0;
BEGIN
FOR I IN V_START..V_END LOOP
TOT := TOT + I;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC3(1, 100);



--예외처리
CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원;
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;

EXEC EXE_TEST;

CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = '2000';
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;




----------------------------------- 2월 4일(금요일) ---------------------------------------------------------------------------


CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS--IS위에 있는것은 외부에서 사용하는것 IS 아래에 있는것은 내부에서 사용하는것
    CURSOR CUR_DEPTNO --CURSOR는 하나의 그릇이다 
    IS -- 밑에 있는 SECELT문을 CURSOR CUR_DEPTNO에 넣는다 
    SELECT 부서번호,사원명,직급,급여 FROM 사원
    WHERE 부서번호=I_DEPTNO;

V_DEPTNO 사원.부서번호%TYPE;--변수 만들것이다 
V_SANAME 사원.사원명%TYPE;--변수 만들것이다 
V_JIK 사원.직급%TYPE;--변수 만들것이다 
V_SAL 사원.급여%TYPE;--변수 만들것이다 

BEGIN

OPEN CUR_DEPTNO; --CURSOR의 내용을 볼려면 일단은 오픈을 해야한다 

DBMS_OUTPUT.PUT_LINE('부서번호 사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE('-------------------------');

LOOP

FETCH CUR_DEPTNO INTO V_DEPTNO,V_SANAME,V_JIK,V_SAL; --FETCH 꺼내오는것

EXIT WHEN CUR_DEPTNO%NOTFOUND;--언제 빠져나갈꺼냐  조건을 건다 

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_DEPTNO)||'  '||
V_SANAME||'  '||V_JIK||'  '||TO_CHAR(V_SAL));

END LOOP;--END LOOP문을 빠져 나온다, 반복문으로 데이터를 다 꺼내왔다 

DBMS_OUTPUT.PUT_LINE('-----------------------');
DBMS_OUTPUT.PUT_LINE('전체데이터 갯수:'||TO_CHAR(CUR_DEPTNO%ROWCOUNT));--객수를 ROWCOUNT로 가져올꺼다 

CLOSE CUR_DEPTNO;--커서를 닫아줘야한다.

END;


--
CREATE OR REPLACE PROCEDURE P_DEPTNO
(I_DEPTNO 사원.부서번호%TYPE)
IS
CURSOR CUR_DEPTNO
IS
SELECT 부서번호,사원명,직급,급여 FROM 사원
WHERE 부서번호=I_DEPTNO;
V_CNT NUMBER;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호  사원명  직급  급여');
DBMS_OUTPUT.PUT_LINE('----------------------------');
FOR CURDEPT IN CUR_DEPTNO LOOP -- CUR_DEPT에서 한개 꺼내서 CURDEPT에 넣어라
DBMS_OUTPUT.PUT_LINE(TO_CHAR(CURDEPT.부서번호)||'  '||
CURDEPT.사원명||'  '||CURDEPT.직급||'  '||TO_CHAR(CURDEPT.급여));
V_CNT := CUR_DEPTNO%ROWCOUNT; --FOR문이 끝나면 사용못하니까 여기서 넣어준다.
END LOOP;
DBMS_OUTPUT.PUT_LINE('--------------------------');
DBMS_OUTPUT.PUT_LINE('전체데이터 갯수: '||TO_CHAR(V_CNT)); --여기엔 V_CNT를 넣어준다.
END;
/

--
--사원번호(USERID)를 입력 시 사원이름과 구입한 제품명을 출력
CREATE OR REPLACE PROCEDURE P_JEPUM
(V_USERID IN VARCHAR2)
IS
V_CNT NUMBER;
CURSOR SA_CUR
IS
SELECT C.USERID, C.USERNAME, S.PRODUCTNAME
FROM CUSTOM C, SALES S
WHERE C.USERID = S.USERID AND S.USERID = V_USERID;
BEGIN
DBMS_OUTPUT.PUT_LINE('아이디  이름  제품명');
DBMS_OUTPUT.PUT_LINE('--------------------');
FOR I IN SA_CUR LOOP
DBMS_OUTPUT.PUT_LINE(I.USERID||'  '||I.USERNAME||'  '||I.PRODUCTNAME);
V_CNT := SA_CUR%ROWCOUNT;
END LOOP;
DBMS_OUTPUT.PUT_LINE('전체데이터의 갯수: '||TO_CHAR(V_CNT));
END;
/


--PACKAGE 눈도장만 찍기

CREATE OR REPLACE PACKAGE BODY SAWON_PACK
IS
    CURSOR SW_CUR
    IS
    SELECT * FROM 사원;
PROCEDURE SANO_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원번호');
DBMS_OUTPUT.PUT_LINE('--------');
FOR K IN SW_CUR LOOP --FOR문 사용
DBMS_OUTPUT.PUT_LINE(K.사원번호);
END LOOP;
END;
PROCEDURE SANNAME_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('사원명');
DBMS_OUTPUT.PUT_LINE('------');
FOR K IN SW_CUR LOOP --FOR문 사용
DBMS_OUTPUT.PUT_LINE(K.사원명);
END LOOP;
END;
PROCEDURE BUNO_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호');
DBMS_OUTPUT.PUT_LINE('------');
FOR K IN SW_CUR LOOP --FOR문 사용
DBMS_OUTPUT.PUT_LINE(K.부서번호);
END LOOP;
END;
PROCEDURE JIK_OUT
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('직급');
DBMS_OUTPUT.PUT_LINE('----');
FOR K IN SW_CUR LOOP --FOR문 사용
DBMS_OUTPUT.PUT_LINE(K.직급);
END LOOP;
END;
END;
/
--검색 하기
EXEC SAWON_PACK.JIK_OUT;




--TRIGGER(트리거)--------
--종류는 AFTER, BEFORE TRIGGER 2개가 있다.

-- AFTER : 사용자가 한 작업 다음에 실행되는게
-- BEFORE : 사용자가 작업을 하면 홀딩시키고 하는거


--AFTER -INSERT
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN -- 앤 자동으로 실행되서 이름이 딱히 상관X
AFTER INSERT
ON LEE.HAKSANG
BEGIN
INSERT INTO MEMO VALUES (SE100. NEXTVAL, '행이 INSERT되었습니다');
END;
/

--결과
SELECT * FROM HAKSANG;
SELECT * FROM MEMO;



SELECT * FROM MEMO
CREATE OR REPLACE TRIGGER TRI_HAKSANG_IN
AFTER INSERT
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, :NEW.NAME || '행이 INSERT되었습니다.');
END;
/

INSERT INTO HAKSANG VALUES(222, 'INNA');
--결과
SELECT * FROM HAKSANG;




--AFTER TRIGGER : UPDATE TRIGGER

CREATE OR REPLACE TRIGGER TRI_HAKSANG_UP
AFTER UPDATE OF NAME
ON LEE.HAKSANG --트리거를 만들때는 스키마를 꼭 써줘야한다.
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES(SE100.NEXTVAL, :OLD.NAME ||  ' 행이 '||:NEW.NAME||'으로 UPDATE되었습니다.');
END;
/
--검색
SELECT * FROM HAKSANG;
SELECT * FROM MEMO;



--AFTER TRIGGER : DELETE TRIGGER

CREATE OR REPLACE TRIGGER TRI_HAKSANG_DEL
AFTER DELETE
ON LEE.HAKSANG
FOR EACH ROW
BEGIN
INSERT INTO MEMO VALUES (SE100.NEXTVAL, :OLD.NAME||'행이 DELETE 됨'); -- OLD는 지워진 데이터
INSERT INTO LEE.COPY_HAKSANG VALUES (:OLD.HAKBUN, :OLD.NAME);
END;
/

DELETE HAKSANG WHERE HAKBUN=111; --삭제하고

--검색
SELECT * FROM HAKSANG;
SELECT * FROM MEMO;
--여기까지가 AFTER 트리거(INSERT,DELETE,UPDATE)



-- BEFORE TRIGGER--------
-- BEFORE TRIGGER (토,일,12-17시 이외에 DML 금지)

--먼저 테이블 만들고
CREATE TABLE INSA
(EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10),
JIK VARCHAR2(10),
SAL NUMBER);



CREATE OR REPLACE TRIGGER TRI_INSA
BEFORE INSERT OR DELETE OR UPDATE
ON LEE.INSA
DECLARE
IMPOSSIBLE_TIME EXCEPTION;
BEGIN
IF TO_CHAR(SYSDATE, 'DAY') IN ('토요일', '일요일') OR
TO_CHAR(SYSDATE, 'HH24') < 12 OR TO_CHAR(SYSDATE, 'HH24') > 17 THEN
RAISE IMPOSSIBLE_TIME;
END IF;
EXCEPTION
WHEN IMPOSSIBLE_TIME THEN
RAISE_APPLICATION_ERROR(-20007, '월요일부터 금요일까지 정오 12:00부터 오후 5시까지만 DML작업이 가능합니다.');
END;
/

INSERT INTO INSA VALUES(1,'배수지','가수',5000);


--검색
SELECT * FROM INSA;





--BEFORE 트리거 ( 주민번호 검사 )

--먼저 테이블 만들기
CREATE TABLE MEMBER
(ID NUMBER(3) PRIMARY KEY,
NAME VARCHAR2(10),
JUBUN VARCHAR2(13));


CREATE OR REPLACE TRIGGER TRI_MEMBER_JUBUN
BEFORE INSERT OR UPDATE OF JUBUN
ON LEE.MEMBER
FOR EACH ROW
DECLARE
A NUMBER; B NUMBER; C NUMBER; D NUMBER; E NUMBER;
F NUMBER; G NUMBER; H NUMBER; I NUMBER; J NUMBER;
K NUMBER; L NUMBER; M NUMBER;
CK NUMBER;
JUBUNFAIL EXCEPTION;
BEGIN
A := SUBSTR(:NEW.JUBUN, 1, 1);
B := SUBSTR(:NEW.JUBUN, 2, 1);
C := SUBSTR(:NEW.JUBUN, 3, 1);
D := SUBSTR(:NEW.JUBUN, 4, 1);
E := SUBSTR(:NEW.JUBUN, 5, 1);
F := SUBSTR(:NEW.JUBUN, 6, 1);
G := SUBSTR(:NEW.JUBUN, 7, 1);
H := SUBSTR(:NEW.JUBUN, 8, 1);
I := SUBSTR(:NEW.JUBUN, 9, 1);
J := SUBSTR(:NEW.JUBUN, 10, 1);
K := SUBSTR(:NEW.JUBUN, 11, 1);
L := SUBSTR(:NEW.JUBUN, 12, 1);
M := SUBSTR(:NEW.JUBUN, 13, 1);
CK := (A*2)+(B*3)+(C*4)+(D*5)+(E*6)+(F*7)+(G*8)+(H*9)+(I*2)+(J*3)+(K*4)+(L*5); --뒤에 곱하는건 주민번호에 고유의 키값이 있는데
CK := MOD(CK, 11);                                           -- 숫자랑 키값을 곱해야 하기때문( 주민번호가 맞는지 확인하는 공식)
CK := 11-CK;                                                 --마지막자리M을 곱하기 안한 이유는 부호비트이기때문
CK := MOD(CK,10);
IF M != CK THEN
RAISE JUBUNFAIL;
END IF;
EXCEPTION
WHEN JUBUNFAIL THEN
RAISE_APPLICATION_ERROR(-20001, '주민번호가 틀렸습니다!');
END;
/

--검사
INSERT INTO MEMBER VALUES (10, 'SUZI', '1111111111111'); --예외처리에 걸려서 틀렸다나옴
INSERT INTO MEMBER VALUES (10, 'SUZI', '9705271211111'); -- 삽입 성공


