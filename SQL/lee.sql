SELECT * FROM TAB;

--모든데이터 가져오기
/* 범위 주석 */
SELECT * FROM CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND(PAY, -4) PAY FROM COMPANY;

SELECT * FROM CUSTOM;

--770322-1****** --주민번호 뽑기
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;


SELECT COUNT(*) INWON FROM CUSTOM
WHERE JOB = '회사원'; -- 177

SELECT COUNT(*) INWON FROM CUSTOM
WHERE SCHOL = '대졸'; -- 43

SELECT COUNT(*) INWON FROM CUSTOM
WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM
WHERE POINT >= 200;


--테이블의 이름과 컬럼의 이름은 중복되면 안된다.
SELECT * FROM COMPANY;

--포지션이 대리인 사람은 몇명이냐
SELECT COUNT(PAY) FROM COMPANY
WHERE POSIT = '대리';

--포지션이 대리인 사람이 받는 PAY의 총합?
SELECT SUM(PAY) FROM COMPANY
WHERE POSIT = '대리';


SELECT * FROM CUSTOM;

--직업 별 인원수 구하기
SELECT JOB, COUNT(*) INWON FROM CUSTOM
GROUP BY JOB;

--학력 별 POINT의 평균 구하기
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM
GROUP BY SCHOL;

--지역별 POINT 합계 구하기 -- ""찍은 이유는 MAX랑 MIN이 함수를 인식될까봐 찍음
SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT) "MAX", MIN(POINT) "MIN" FROM CUSTOM
GROUP BY ADDR1;


--성별 나이의 평균, 인원수 구하기
SELECT SEX,ROUND(AVG(AGE))"AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;


SELECT
CASE SEX
WHEN '1' THEN '남자'
WHEN '0' THEN '여자'
END GENDER
, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT"
FROM CUSTOM
GROUP BY SEX;

/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100                          
	WHEN 2 THEN 200                         
	WHEN 3 THEN 300                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT             
FROM DUAL;
*/



SELECT * FROM COMPANY;

--직책별 월급의 합, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT; -- DB에 없는 컬럼으로 만들어서 이 테이플은 파생 테이블이다.


--직책별 월급의 합, 평균, MAX, MIN (HAVING 사용하기)
--ORDER BY는 별칭을 써도 정렬되지만 나머지는 안된다. 
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT 
HAVING COUNT(*) > 60;

--------------------1월 25일 --------------------------------------------------------------------------------------------

--JOIN문
/*
EQUI JOIN(INNER JOIN)
NON-EQUI JOIN -- 이건 오라클에만 존재.
OUTER JOIN
CROSS JOIN -- 사용 거의 안함
SELF JOIN
INNER(EQUI)는 90%  SELF 는 10% 이 2개는 많이 사용함
*/


--EQUI JOIN(INNER JOIN) -- 오라클 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B --컬럼명에는 AS를 써서 별칭을 쓰지만 테이블 별칭은 AS 쓰면 X
WHERE A.USERID = B.USERID;

--INNER JOIN - 표준 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B  -- INNER를 생략하고 해도 문제 없음
ON A.USERID = B.USERID;

--테이블 'CUSTOM'에서 UserID, UserName을 검색하고
--POINT 테이블에서 제품 구입, 로그인에 관계된 POINT 점수(Product, Login)를 검색
SELECT * FROM POINT;

SELECT A.USERID,USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

SELECT A.USERID,USERNAME, PRODUCT, LOGIN  --위와 동일 결과
FROM CUSTOM A INNER JOIN POINT B -- INNER 생략가능
ON A.USERID = B.USERID -- AND LOGIN >= 10; -> 여기다 써도 되고
WHERE LOGIN >= 10; -- 여기다 써도 된다.




--OUTER JOIN(외부 조인)
--특정 테이블이 기준이되서 데이터를 찾아옴. ( 자주 사용X 그래도 기본은 알고있어야함)

SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
WHERE A.USERID = B.USERID(+);

--위를 ANSI표준으로 만들면(위와 같음)
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
ON A.USERID = B.USERID(+);

-------------------------------------------------------------------------
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
WHERE A.USERID(+) = B.USERID;

--위를 ANSI 표준으로 만들면
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
ON A.USERID(+) = B.USERID;


SELECT * FROM RESEARCH;

SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID 
WHERE ANSWER IS NULL;

-----------여기까지가 OUTER JOIN---------------------------------------------------------


--CROSS JOIN(상호 조인)
SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; -- 464



SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT 
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID; -- CROSS JOIN은 INNER JOIN에서 이 줄을 빼면 된다.



-- SELF JOIN

SELECT * FROM CUSTOM;

DESC CUSTOM;

--동명이인 잡아내는 공식
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID -- A.USERID와 B.USERID가 틀려야함
ORDER BY A.USERNAME;


-- 'CUSTOM' 테이블에서 '제주도'에 살고 있는 사람 중에 동일한 이름을 갖는 행을 검색

SELECT * FROM CUSTOM WHERE ADDR1 = '제주도'; -- 14명나옴


SELECT DISTINCT A.* -- 제주도에 사는 사람이 동명 3인이상이면 DISTINCT를 써준다. 2인까지는 안써도된다.
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;



SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;

SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT * FROM CUSTOM;


CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT * FROM JEJU;


CREATE TABLE KYUNG
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

SELECT * FROM KYUNG;


CREATE TABLE SEOUL
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

SELECT * FROM SEOUL;

----------------
SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;




--  SUB-QUERY(하위쿼리) : 쿼리 안에 쿼리를 넣는다.          - 하위 쿼리는 반드시 괄호로 묶어줘야한다.

-- 'COMPANY' 테이블에서 UserID, Company, Dept, Pay와 평균 월급을 검색
SELECT USERID, COMPANY, DEPT, PAY AVG(PAY)FROM COMPANY; -- X 에러남 해결방법은 아래


SELECT ROUND(AVG(PAY)) FROM COMPANY;

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY; -- 이렇게 하면 값을 받기위해 2번을 실행하니 이렇게 하면 X


--정석 방법
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY, --하위쿼리는 연산 가능
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) 차액
FROM COMPANY;

--'CUSTOM' 테이블에서 평균 나이 이상인 행들을 검색하시오.

SELECT AVG(AGE) FROM CUSTOM;

SELECT * FROM CUSTOM WHERE AGE>= 28;


--->
SELECT * FROM CUSTOM WHERE AGE>= (SELECT AVG(AGE) FROM CUSTOM);

--'COMPANY' 테이블에서 평균 월급보다 적은 월급을 받는 행을 검색

SELECT * FROM COMPANY 
WHERE  PAY < (SELECT AVG(PAY) FROM COMPANY);


-- '현대자동차' 회사에 근무하는 고객의 UserID, UserName, Addr1, Schol 열을 검색

SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224', 'el3409');
--WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');


--JOIN문으로 바꿔서 하면 ( 하위 쿼리는 JOIN문으로 바꿔서 할 수 있다.)
--SELECT A. *, COMPANY
SELECT A.USERID,USERNAME, ADDR1,SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID AND COMPANY LIKE '현대자동차%';


--SALSE 테이블에서 4회 이상 판매 기록이 있는 고객들의 기본 정보를 검색

SELECT * FROM SALES -- SALES테이블
ORDER BY USERID;



--SALES 테이블에서 4회 이상 판매 기록이 있는 고객
SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;


SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--> JOIN문으로 바꾸면

--INLINE VIEW
SELECT A.*,CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4) B
WHERE A.USERID = B.USERID;

/*
SELECT A.*
FROM () A, () B
WHERE A.USERID = B.USERID;
*/



-- 총 판매 금액이 100만원 이상인 'CUSTOM' 테이블에는 고객의 기본 정보

--먼저 100만원 이상인 사람 찾기
SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000;



--하위 쿼리
SELECT * FROM CUSTOM
WHERE USERID IN 
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000);

--JOIN

SELECT A.*, CNT, HAP
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;


--ANY, ALL

--ANY는 범위값을 무조건 포함하고 있어야하고, ALL은 범위값을 포함 X

SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도' ORDER BY POINT;

/*
132 ~ 269
>ANY : 132보다 큰 데이터
<ANY : 269보다 작은 데이터
>ALL : 269보다 큰 데이터
<ANY : 132보다 작은 데이터
*/

--ANY가 MIN보다 연산속도가 훨씬 빠르다.
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------


SELECT * FROM CUSTOM WHERE POINT = 131;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';


--------------------------------------------------------------------------------
-- IN과 =ANY 연산자는 같다
--현대자동차에 근무하는 사람은?

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID = ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <> ALL (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
--여기를 하단 상관 쿼리로 바꿈
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관 쿼리(눈도장만 찍어놓기) - EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--------------------------------------------------------------------------------
--상관 쿼리(눈도장만 찍어놓기) - NOT EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--상관쿼리는 독자적으로 실행X

--------------------------------------------------------------------------------
--경기도에 살면서 나이가 20보다 작은 사람
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;


SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A;

--위와 다른방법
SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A
WHERE A.AGE<=20;