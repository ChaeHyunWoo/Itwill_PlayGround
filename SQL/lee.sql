SELECT * FROM TAB;

--모든데이터 가져오기
/* 범위 주석 */
SELECT * FROM CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND(PAY, -4) PAY FROM COMPANY;

SELECT * FROM CUSTOM;

--770322-1****** --주민번호 뽑기
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;


SELECT COUNT(*) INWON FROM CUSTOM
WHERE JOB = '회사원'; -- 177

SELECT COUNT(*) INWON FROM CUSTOM
WHERE SCHOL = '대졸'; -- 43

SELECT COUNT(*) INWON FROM CUSTOM
WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM
WHERE POINT >= 200;


--테이블의 이름과 컬럼의 이름은 중복되면 안된다.
SELECT * FROM COMPANY;

--포지션이 대리인 사람은 몇명이냐
SELECT COUNT(PAY) FROM COMPANY
WHERE POSIT = '대리';

--포지션이 대리인 사람이 받는 PAY의 총합?
SELECT SUM(PAY) FROM COMPANY
WHERE POSIT = '대리';


SELECT * FROM CUSTOM;

--직업 별 인원수 구하기
SELECT JOB, COUNT(*) INWON FROM CUSTOM
GROUP BY JOB;

--학력 별 POINT의 평균 구하기
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM
GROUP BY SCHOL;

--지역별 POINT 합계 구하기 -- ""찍은 이유는 MAX랑 MIN이 함수를 인식될까봐 찍음
SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT) "MAX", MIN(POINT) "MIN" FROM CUSTOM
GROUP BY ADDR1;


--성별 나이의 평균, 인원수 구하기
SELECT SEX,ROUND(AVG(AGE))"AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;


SELECT
CASE SEX
WHEN '1' THEN '남자'
WHEN '0' THEN '여자'
END GENDER
, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT"
FROM CUSTOM
GROUP BY SEX;

/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100                          
	WHEN 2 THEN 200                         
	WHEN 3 THEN 300                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT             
FROM DUAL;
*/



SELECT * FROM COMPANY;

--직책별 월급의 합, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT; -- DB에 없는 컬럼으로 만들어서 이 테이플은 파생 테이블이다.


--직책별 월급의 합, 평균, MAX, MIN (HAVING 사용하기)
--ORDER BY는 별칭을 써도 정렬되지만 나머지는 안된다. 
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT 
HAVING COUNT(*) > 60;

--------------------1월 25일 --------------------------------------------------------------------------------------------

--JOIN문
/*
EQUI JOIN(INNER JOIN)
NON-EQUI JOIN -- 이건 오라클에만 존재.
OUTER JOIN
CROSS JOIN -- 사용 거의 안함
SELF JOIN
INNER(EQUI)는 90%  SELF 는 10% 이 2개는 많이 사용함
*/


--EQUI JOIN(INNER JOIN) -- 오라클 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B --컬럼명에는 AS를 써서 별칭을 쓰지만 테이블 별칭은 AS 쓰면 X
WHERE A.USERID = B.USERID;

--INNER JOIN - 표준 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B  -- INNER를 생략하고 해도 문제 없음
ON A.USERID = B.USERID;

--테이블 'CUSTOM'에서 UserID, UserName을 검색하고
--POINT 테이블에서 제품 구입, 로그인에 관계된 POINT 점수(Product, Login)를 검색
SELECT * FROM POINT;

--EQUI JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

--INNER JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN  --위와 동일 결과
FROM CUSTOM A INNER JOIN POINT B -- INNER 생략가능
ON A.USERID = B.USERID -- AND LOGIN >= 10; -> 여기다 써도 되고
WHERE LOGIN >= 10; -- 여기다 써도 된다.




--OUTER JOIN(외부 조인)
--특정 테이블이 기준이되서 데이터를 찾아옴. ( 자주 사용X 그래도 기본은 알고있어야함)

SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
WHERE A.USERID = B.USERID(+);

--위를 ANSI표준으로 만들면(위와 같음)
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
ON A.USERID = B.USERID(+);

-------------------------------------------------------------------------
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
WHERE A.USERID(+) = B.USERID;

--위를 ANSI 표준으로 만들면
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
ON A.USERID(+) = B.USERID;


SELECT * FROM RESEARCH;

SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID 
WHERE ANSWER IS NULL;

-----------여기까지가 OUTER JOIN---------------------------------------------------------


--CROSS JOIN(상호 조인)
SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; -- 464



SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT 
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID; -- CROSS JOIN은 INNER JOIN에서 이 줄을 빼면 된다.



-- SELF JOIN

SELECT * FROM CUSTOM;

DESC CUSTOM;

--동명이인 잡아내는 공식
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID -- A.USERID와 B.USERID가 틀려야함
ORDER BY A.USERNAME;


-- 'CUSTOM' 테이블에서 '제주도'에 살고 있는 사람 중에 동일한 이름을 갖는 행을 검색

SELECT * FROM CUSTOM WHERE ADDR1 = '제주도'; -- 14명나옴


SELECT DISTINCT A.* -- 제주도에 사는 사람이 동명 3인이상이면 DISTINCT를 써준다. 2인까지는 안써도된다.
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;



SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;

SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT * FROM CUSTOM;


CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT * FROM JEJU;


CREATE TABLE KYUNG
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

SELECT * FROM KYUNG;


CREATE TABLE SEOUL
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

SELECT * FROM SEOUL;

----------------
SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;




--  SUB-QUERY(하위쿼리) : 쿼리 안에 쿼리를 넣는다.          - 하위 쿼리는 반드시 괄호로 묶어줘야한다.

-- 'COMPANY' 테이블에서 UserID, Company, Dept, Pay와 평균 월급을 검색
SELECT USERID, COMPANY, DEPT, PAY AVG(PAY)FROM COMPANY; -- X 에러남 해결방법은 아래


SELECT ROUND(AVG(PAY)) FROM COMPANY;

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY; -- 이렇게 하면 값을 받기위해 2번을 실행하니 이렇게 하면 X


--정석 방법
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY, --하위쿼리는 연산 가능
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) 차액
FROM COMPANY;

--'CUSTOM' 테이블에서 평균 나이 이상인 행들을 검색하시오.

SELECT AVG(AGE) FROM CUSTOM;

SELECT * FROM CUSTOM WHERE AGE>= 28;


--->
SELECT * FROM CUSTOM WHERE AGE>= (SELECT AVG(AGE) FROM CUSTOM);

--'COMPANY' 테이블에서 평균 월급보다 적은 월급을 받는 행을 검색

SELECT * FROM COMPANY 
WHERE  PAY < (SELECT AVG(PAY) FROM COMPANY);


-- '현대자동차' 회사에 근무하는 고객의 UserID, UserName, Addr1, Schol 열을 검색

SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224', 'el3409');
--WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');


--JOIN문으로 바꿔서 하면 ( 하위 쿼리는 JOIN문으로 바꿔서 할 수 있다.)
--SELECT A. *, COMPANY
SELECT A.USERID,USERNAME, ADDR1,SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID AND COMPANY LIKE '현대자동차%';


--SALSE 테이블에서 4회 이상 판매 기록이 있는 고객들의 기본 정보를 검색

SELECT * FROM SALES -- SALES테이블
ORDER BY USERID;



--SALES 테이블에서 4회 이상 판매 기록이 있는 고객
SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;


SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--> JOIN문으로 바꾸면

--INLINE VIEW
SELECT A.*,CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4) B
WHERE A.USERID = B.USERID;

/*
SELECT A.*
FROM () A, () B
WHERE A.USERID = B.USERID;
*/



-- 총 판매 금액이 100만원 이상인 'CUSTOM' 테이블에는 고객의 기본 정보

--먼저 100만원 이상인 사람 찾기
SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000;



--하위 쿼리
SELECT * FROM CUSTOM
WHERE USERID IN 
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000);

--JOIN

SELECT A.*, CNT, HAP
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;


--ANY, ALL

--ANY는 범위값을 무조건 포함하고 있어야하고, ALL은 범위값을 포함 X

SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도' ORDER BY POINT;

/*
132 ~ 269
>ANY : 132보다 큰 데이터
<ANY : 269보다 작은 데이터
>ALL : 269보다 큰 데이터
<ANY : 132보다 작은 데이터
*/

--ANY가 MIN보다 연산속도가 훨씬 빠르다.
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------


SELECT * FROM CUSTOM WHERE POINT = 131;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';


--------------------------------------------------------------------------------
-- IN과 =ANY 연산자는 같다
--현대자동차에 근무하는 사람은?

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID = ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <> ALL (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
--여기를 하단 상관 쿼리로 바꿈
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관 쿼리(눈도장만 찍어놓기) - EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--------------------------------------------------------------------------------
--상관 쿼리(눈도장만 찍어놓기) - NOT EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--상관쿼리는 독자적으로 실행X

--------------------------------------------------------------------------------
--경기도에 살면서 나이가 20보다 작은 사람
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;


SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A;

--위와 다른방법
SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A
WHERE A.AGE<=20;


---------------------------------------------------2월 3일------------------------------------------------------------------



create table 사원
(사원번호 number(10),
사원명 varchar2(10),
부서번호 number(2),
직급 varchar2(10),
우편번호 char(7),
주소 varchar2(50),
전화번호 char(15),
급여 number(5),
커미션 number(5),
입사일 date,
성별 char(6),
사수번호 number(10)
);


insert into 사원 values(2001,'이순신',10,'부장','125-365','서울 용산구','02-985-1254',3500,100,'1980-12-01','남자',null);
insert into 사원 values(2002,'홍길동',10,'대리','354-865','서울 강남구','02-865-1254',4000,'','2000-01-25','남자',2004);
insert into 사원 values(2003,'성유리',20,'사원','587-456','부산 해운대구','051-256-9874',2500,100,'2002-05-24','여자',2002);
insert into 사원 values(2004,'옥주현',30,'과장','987-452','서울 강남구','02-33-6589',5000,'','1997-03-22','여자',2001);
insert into 사원 values(2005,'길건',10,'대리','123-322','서울 성동구','02-888-9564',3000,100,'1999-07-15','여자',2004);
insert into 사원 values(2006,'한지혜',20,'사원','154-762','서울 송파구','02-3369-9874',2000,'','2003-05-22','여자',2005);
insert into 사원 values(2007,'박솔미',30,'대리','367-985','서울 영등포구','02-451-2563',3000,100,'2006-01-25','여자',2004);
insert into 사원 values(2008,'이효리',40,'사원','552-126','서울 중구','02-447-3256',2000,'','2001-02-02','여자',2007);

select * from 사원;
DESC 사원; --사원 테이블의 자료형이 나옴
commit;

-----------------------------------------이게 PL SQL이다.
--select,insert,update,delete만 사용가능
DECLARE
TYPE FIRSTTYPE IS RECORD
--(A VARCHAR2, B VARCHAR2, C NUMBER); -- 이렇게 써도 되지만 
(A 사원.사원명%TYPE,B 사원.직급%TYPE, C 사원.급여%TYPE); -- 좀더 쉽게 쓸수 있다 

CUS FIRSTTYPE;--CUS라는 변수를 선언하고 FORSTTYPE를 CUS에 넣는다 

BEGIN --문으로 시작하고 
SELECT 사원명,직급,급여 INTO CUS FROM 사원 WHERE 사원번호=2001;--사원명 직급 급여 INTO해서 CUS에 넣는다 

DBMS_OUTPUT.PUT_LINE('--------------------------');
DBMS_OUTPUT.PUT_LINE('사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE(CUS.A||'  '||CUS.B||'  '||TO_CHAR(CUS.C));
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정은 '||USER||'입니다');--여기서 USER는 SYSTEM 변수이다 
DBMS_OUTPUT.PUT_LINE('현재 질의한 시간은 '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MM:SS'));--SYDATE를 읽어와서 내가 원하는 입맛으로 표현한다 
END;--끝난다

SELECT * FROM 사원;

SELECT 사원번호,사원명,직급,급여,커미션,F_TAX(2001) TAX FROM 사원 -- 함수부분 CMD캡처한걸 여기서 실행
WHERE 사원번호=2001;


--지금부터하는 코딩은  SCRIPT(파일)로 저장한다
ACCEPT ID PROMPT '검색할 아이디를 입력하세요: ';--ID는 사용자정의 변수

DECLARE

TYPE GOGAK IS RECORD --GOGAK이라는 데이터타입(RECORD)를 만듬
(A CUSTOM.USERID%TYPE, --A라는 변수를 만들고 
B CUSTOM.USERNAME%TYPE,
C NUMBER(12,2),
D NUMBER(5));

CUS GOGAK;

BEGIN
SELECT C.USERID, C.USERNAME, S.합계, S.구입횟수 INTO CUS
FROM CUSTOM C, --CUSTOM를 C라 하고
(SELECT USERID, SUM(PRICE) 합계, COUNT(*) 구입횟수
FROM SALES
GROUP BY USERID) S --이 괄호를 S로 만듬
WHERE C.USERID = S.USERID AND C.USERID ='&ID';--ACCEPT ID PROMPT 위의 ID값을 가져옴

DBMS_OUTPUT.PUT_LINE('아이디: '||CUS.A);
DBMS_OUTPUT.PUT_LINE('이  름: '||CUS.B);
DBMS_OUTPUT.PUT_LINE('판매액: '||CUS.C);
DBMS_OUTPUT.PUT_LINE('금  액: '||CUS.D);

END;

SELECT * FROM CUSTOM;


--직책을 입력 받아 그 직책의 급여의 총액,평균월급,인원수를 찾으시오

CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS --IS를 기준으로 아래는 블럭 안에서 사용할 변수
A NUMBER;=0;
B NUMBER(12,2);=0; --여긴 자릿값을 줬음
C NUMBER:=0;
BEGIN
SELECT SUM(PAY),AVG(PAY),COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT=JIK;

DMBS_OUTPUT.PUT.LINE('급여총액: '||A||'원');
DMBS_OUTPUT.PUT.LINE('평균월급: '||B||'원');
DMBS_OUTPUT.PUT.LINE('인원수: '||C||'명');
END SEARCHJIK; --END뒤에 SEARCHJIK생략가능


SELECT * FROM COMPANY;

SELECT SUM(PAY),ROUND(AVG(PAY)),COUNT(*)
FROM COMPANY WHERE POSIT=JIK;
GROUP BY POSIT;





--CUSTOM 테이블에 INSERT 시키는 프로시저(CUS_IN)
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,
F VARCHAR2,G VARCHAR2,H VARCHAR2,I VARCHAR2,J VARCHAR2,
K VARCHAR2,L VARCHAR2,M NUMBER,N DATE,)
IS
BEGIN
INSERT INTO CUSTOM VALUES (A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;

EXEC CUS_IN('A002','INNA','123',27,'0','123-123','서울',
'강남구','역삼동','010-123-1234','가수','대졸',123,SYSDATE);

--CUSTOM 테이블에 UPDATE 시키는 프로시저(CUS_UP)
CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,
F VARCHAR2,G VARCHAR2,H VARCHAR2,I VARCHAR2,J VARCHAR2,
K VARCHAR2,L VARCHAR2,M NUMBER,N DATE,)
IS
BEGIN
UPDATE CUSTOM SET USERNAME=B, JUMIN=C, AGE=D, SEX=E,
ZIP=F, ADDR1=G, ADDR2=H, ADDR3=I, TEL=J, JOB=K, SCHOL=L,
POINT=M, REGDATE=N
WHERE USERID=A;
COMMIT;
END;



--CUSTOM 테이블에 DELETE 시키는 프로시져(CUS_DEL)
CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS
BEGIN
DELETE CUSTOM WHERE USERNAME=B, JUMIN=C, AGE=D, SEX=E,
ZIP=F, ADDR1=G, ADDR2=H, ADDR3=I, TEL=J, JOB=K, SCHOL=L,











