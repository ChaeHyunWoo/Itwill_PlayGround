SELECT * FROM TAB;

--모든데이터 가져오기
/* 범위 주석 */
SELECT * FROM CUSTOM;

SELECT * FROM COMPANY;

SELECT USERID, PAY, ROUND(PAY, -4) PAY FROM COMPANY;

SELECT * FROM CUSTOM;

--770322-1****** --주민번호 뽑기
SELECT RPAD(SUBSTR(JUMIN, 1, 8), 14, '*') JUMIN FROM CUSTOM;


SELECT COUNT(*) INWON FROM CUSTOM
WHERE JOB = '회사원'; -- 177

SELECT COUNT(*) INWON FROM CUSTOM
WHERE SCHOL = '대졸'; -- 43

SELECT COUNT(*) INWON FROM CUSTOM
WHERE ADDR1 LIKE '서울%';

SELECT COUNT(*) INWON FROM CUSTOM
WHERE POINT >= 200;


--테이블의 이름과 컬럼의 이름은 중복되면 안된다.
SELECT * FROM COMPANY;

--포지션이 대리인 사람은 몇명이냐
SELECT COUNT(PAY) FROM COMPANY
WHERE POSIT = '대리';

--포지션이 대리인 사람이 받는 PAY의 총합?
SELECT SUM(PAY) FROM COMPANY
WHERE POSIT = '대리';


SELECT * FROM CUSTOM;

--직업 별 인원수 구하기
SELECT JOB, COUNT(*) INWON FROM CUSTOM
GROUP BY JOB;

--학력 별 POINT의 평균 구하기
SELECT SCHOL, ROUND(AVG(POINT)) INWON FROM CUSTOM
GROUP BY SCHOL;

--지역별 POINT 합계 구하기 -- ""찍은 이유는 MAX랑 MIN이 함수를 인식될까봐 찍음
SELECT ADDR1, ROUND(SUM(POINT)) INWON, MAX(POINT) "MAX", MIN(POINT) "MIN" FROM CUSTOM
GROUP BY ADDR1;


--성별 나이의 평균, 인원수 구하기
SELECT SEX,ROUND(AVG(AGE))"AVG", COUNT(*) "CNT" FROM CUSTOM GROUP BY SEX;


SELECT
CASE SEX
WHEN '1' THEN '남자'
WHEN '0' THEN '여자'
END GENDER
, ROUND(AVG(AGE)) "AVG", COUNT(*) "CNT"
FROM CUSTOM
GROUP BY SEX;

/*
SELECT 
CASE 컬럼명                         
	WHEN 1 THEN 100                          
	WHEN 2 THEN 200                         
	WHEN 3 THEN 300                         
	WHEN 4 THEN 400                          
	ELSE 500                        
END AS RESULT             
FROM DUAL;
*/



SELECT * FROM COMPANY;

--직책별 월급의 합, 평균, MAX, MIN
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT; -- DB에 없는 컬럼으로 만들어서 이 테이플은 파생 테이블이다.


--직책별 월급의 합, 평균, MAX, MIN (HAVING 사용하기)
--ORDER BY는 별칭을 써도 정렬되지만 나머지는 안된다. 
SELECT POSIT, COUNT(*) CNT, ROUND(AVG(PAY)) 평균, MAX(PAY) 최대, MIN(PAY) 최소
FROM COMPANY GROUP BY POSIT 
HAVING COUNT(*) > 60;

--------------------1월 25일 --------------------------------------------------------------------------------------------

--JOIN문
/*
EQUI JOIN(INNER JOIN)
NON-EQUI JOIN -- 이건 오라클에만 존재.
OUTER JOIN
CROSS JOIN -- 사용 거의 안함
SELF JOIN
INNER(EQUI)는 90%  SELF 는 10% 이 2개는 많이 사용함
*/


--EQUI JOIN(INNER JOIN) -- 오라클 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A, COMPANY B --컬럼명에는 AS를 써서 별칭을 쓰지만 테이블 별칭은 AS 쓰면 X
WHERE A.USERID = B.USERID;

--INNER JOIN - 표준 SQL
SELECT A.USERID, USERNAME, ADDR1, B.USERID, COMPANY, DEPT, POSIT, PAY
FROM CUSTOM A INNER JOIN COMPANY B  -- INNER를 생략하고 해도 문제 없음
ON A.USERID = B.USERID;

--테이블 'CUSTOM'에서 UserID, UserName을 검색하고
--POINT 테이블에서 제품 구입, 로그인에 관계된 POINT 점수(Product, Login)를 검색
SELECT * FROM POINT;

--EQUI JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN
FROM CUSTOM A, POINT B
WHERE A.USERID = B.USERID AND LOGIN >= 10;

--INNER JOIN으로 풀기
SELECT A.USERID,USERNAME, PRODUCT, LOGIN  --위와 동일 결과
FROM CUSTOM A INNER JOIN POINT B -- INNER 생략가능
ON A.USERID = B.USERID -- AND LOGIN >= 10; -> 여기다 써도 되고
WHERE LOGIN >= 10; -- 여기다 써도 된다.




--OUTER JOIN(외부 조인)
--특정 테이블이 기준이되서 데이터를 찾아옴. ( 자주 사용X 그래도 기본은 알고있어야함)

SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; --464

SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
WHERE A.USERID = B.USERID(+);

--위를 ANSI표준으로 만들면(위와 같음)
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A LEFT OUTER JOIN COMPANY B -- COMPANY A를 기준으로 하면 (+)를 뒤에 쓴다.
ON A.USERID = B.USERID(+);

-------------------------------------------------------------------------
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A, COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
WHERE A.USERID(+) = B.USERID;

--위를 ANSI 표준으로 만들면
SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT
FROM CUSTOM A RIGHT OUTER JOIN COMPANY B -- COMPANY B를 기준으로 하면 (+)를 앞에 쓴다
ON A.USERID(+) = B.USERID;


SELECT * FROM RESEARCH;

SELECT COUNT(*) FROM RESEARCH;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A, RESEARCH B
WHERE A.USERID = B.USERID(+) AND ANSWER IS NULL;

SELECT A.USERID, USERNAME, ANSWER
FROM CUSTOM A LEFT OUTER JOIN RESEARCH B
ON A.USERID = B.USERID 
WHERE ANSWER IS NULL;

-----------여기까지가 OUTER JOIN---------------------------------------------------------


--CROSS JOIN(상호 조인)
SELECT COUNT(*) FROM CUSTOM; --459
SELECT COUNT(*) FROM COMPANY; -- 464



SELECT A.USERID, USERNAME, ADDR1, COMPANY, DEPT 
FROM CUSTOM A, COMPANY B;
--WHERE A.USERID = B.USERID; -- CROSS JOIN은 INNER JOIN에서 이 줄을 빼면 된다.



-- SELF JOIN

SELECT * FROM CUSTOM;

DESC CUSTOM;

--동명이인 잡아내는 공식
SELECT DISTINCT A.*
FROM CUSTOM A, CUSTOM B
WHERE A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID -- A.USERID와 B.USERID가 틀려야함
ORDER BY A.USERNAME;


-- 'CUSTOM' 테이블에서 '제주도'에 살고 있는 사람 중에 동일한 이름을 갖는 행을 검색

SELECT * FROM CUSTOM WHERE ADDR1 = '제주도'; -- 14명나옴


SELECT DISTINCT A.* -- 제주도에 사는 사람이 동명 3인이상이면 DISTINCT를 써준다. 2인까지는 안써도된다.
FROM CUSTOM A INNER JOIN CUSTOM B
ON A.USERNAME = B.USERNAME
AND A.USERID<>B.USERID
AND A.ADDR1 = '제주도' AND B.ADDR1 = '제주도'
ORDER BY A.USERNAME;



SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A, COMPANY B, POINT C
WHERE A.USERID = B.USERID AND A.USERID = C.USERID;

SELECT A.USERID, USERNAME, COMPANY, DEPT, PRODUCT, LOGIN
FROM CUSTOM A INNER JOIN COMPANY B
ON A.USERID = B.USERID INNER JOIN POINT C
ON A.USERID = C.USERID;

--UNION/ALL

SELECT * FROM CUSTOM;


CREATE TABLE JEJU
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '제주도';

SELECT * FROM JEJU;


CREATE TABLE KYUNG
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도';

SELECT * FROM KYUNG;


CREATE TABLE SEOUL
AS
SELECT * FROM CUSTOM WHERE ADDR1 = '서울특별시';

SELECT * FROM SEOUL;

----------------
SELECT * FROM JEJU
UNION
SELECT * FROM KYUNG
UNION
SELECT * FROM SEOUL;




--  SUB-QUERY(하위쿼리) : 쿼리 안에 쿼리를 넣는다.          - 하위 쿼리는 반드시 괄호로 묶어줘야한다.

-- 'COMPANY' 테이블에서 UserID, Company, Dept, Pay와 평균 월급을 검색
SELECT USERID, COMPANY, DEPT, PAY AVG(PAY)FROM COMPANY; -- X 에러남 해결방법은 아래


SELECT ROUND(AVG(PAY)) FROM COMPANY;

SELECT USERID, COMPANY, DEPT, PAY, 1782888 AVG_PAY FROM COMPANY; -- 이렇게 하면 값을 받기위해 2번을 실행하니 이렇게 하면 X


--정석 방법
SELECT USERID, COMPANY, DEPT, PAY,
(SELECT ROUND(AVG(PAY)) FROM COMPANY) AVG_PAY, --하위쿼리는 연산 가능
PAY - (SELECT ROUND(AVG(PAY)) FROM COMPANY) 차액
FROM COMPANY;

--'CUSTOM' 테이블에서 평균 나이 이상인 행들을 검색하시오.

SELECT AVG(AGE) FROM CUSTOM;

SELECT * FROM CUSTOM WHERE AGE>= 28;


--->
SELECT * FROM CUSTOM WHERE AGE>= (SELECT AVG(AGE) FROM CUSTOM);

--'COMPANY' 테이블에서 평균 월급보다 적은 월급을 받는 행을 검색

SELECT * FROM COMPANY 
WHERE  PAY < (SELECT AVG(PAY) FROM COMPANY);


-- '현대자동차' 회사에 근무하는 고객의 UserID, UserName, Addr1, Schol 열을 검색

SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%';

SELECT * FROM CUSTOM
WHERE USERID IN('EE9224', 'el3409');
--WHERE USERID = 'EE9224' OR USERID = 'el3409';

SELECT * FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');


--JOIN문으로 바꿔서 하면 ( 하위 쿼리는 JOIN문으로 바꿔서 할 수 있다.)
--SELECT A. *, COMPANY
SELECT A.USERID,USERNAME, ADDR1,SCHOL, COMPANY
FROM CUSTOM A, COMPANY B
WHERE A.USERID = B.USERID AND COMPANY LIKE '현대자동차%';


--SALSE 테이블에서 4회 이상 판매 기록이 있는 고객들의 기본 정보를 검색

SELECT * FROM SALES -- SALES테이블
ORDER BY USERID;



--SALES 테이블에서 4회 이상 판매 기록이 있는 고객
SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4;


SELECT * FROM CUSTOM
WHERE USERID IN
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4);

--> JOIN문으로 바꾸면

--INLINE VIEW
SELECT A.*,CNT
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT FROM SALES
GROUP BY USERID
HAVING COUNT(*) >= 4) B
WHERE A.USERID = B.USERID;

/*
SELECT A.*
FROM () A, () B
WHERE A.USERID = B.USERID;
*/



-- 총 판매 금액이 100만원 이상인 'CUSTOM' 테이블에는 고객의 기본 정보

--먼저 100만원 이상인 사람 찾기
SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000;



--하위 쿼리
SELECT * FROM CUSTOM
WHERE USERID IN 
(SELECT USERID FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000);

--JOIN

SELECT A.*, CNT, HAP
FROM CUSTOM A, 
(SELECT USERID, COUNT(*) CNT, SUM(PRICE) HAP FROM SALES
GROUP BY USERID
HAVING SUM(PRICE) >= 1000000) B
WHERE A.USERID = B.USERID;


--ANY, ALL

--ANY는 범위값을 무조건 포함하고 있어야하고, ALL은 범위값을 포함 X

SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도' ORDER BY POINT;

/*
132 ~ 269
>ANY : 132보다 큰 데이터
<ANY : 269보다 작은 데이터
>ALL : 269보다 큰 데이터
<ANY : 132보다 작은 데이터
*/

--ANY가 MIN보다 연산속도가 훨씬 빠르다.
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT > ALL ANY (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MAX(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------
SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < ALL (SELECT POINT FROM CUSTOM WHERE ADDR1 = '제주도');


SELECT USERID, USERNAME, POINT FROM CUSTOM
WHERE POINT < (SELECT MIN(POINT) FROM CUSTOM WHERE ADDR1 = '제주도');
--------------------------------------------------------------------------------


SELECT * FROM CUSTOM WHERE POINT = 131;

UPDATE CUSTOM SET POINT = 131 WHERE USERID = 'nn4942';


--------------------------------------------------------------------------------
-- IN과 =ANY 연산자는 같다
--현대자동차에 근무하는 사람은?

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID = ANY (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID <> ALL (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--------------------------------------------------------------------------------
--여기를 하단 상관 쿼리로 바꿈
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE USERID NOT IN (SELECT USERID FROM COMPANY WHERE COMPANY LIKE '현대자동차%');

--상관 쿼리(눈도장만 찍어놓기) - EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--------------------------------------------------------------------------------
--상관 쿼리(눈도장만 찍어놓기) - NOT EXISTS
SELECT USERID, USERNAME, ADDR1, SCHOL FROM CUSTOM
WHERE NOT EXISTS -- 근무하지 않는 사람을 찾을거면 WHERE NOT EXISTS로 하면 된다.
(SELECT * FROM COMPANY 
WHERE USERID = CUSTOM.USERID AND COMPANY LIKE '현대자동차%');
--상관쿼리는 독자적으로 실행X

--------------------------------------------------------------------------------
--경기도에 살면서 나이가 20보다 작은 사람
SELECT * FROM CUSTOM WHERE ADDR1 = '경기도' AND AGE <= 20;


SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A;

--위와 다른방법
SELECT * FROM (SELECT * FROM CUSTOM WHERE ADDR1 = '경기도') A
WHERE A.AGE<=20;


---------------------------------------------------2월 3일------------------------------------------------------------------



create table 사원
(사원번호 number(10),
사원명 varchar2(10),
부서번호 number(2),
직급 varchar2(10),
우편번호 char(7),
주소 varchar2(50),
전화번호 char(15),
급여 number(5),
커미션 number(5),
입사일 date,
성별 char(6),
사수번호 number(10)
);


insert into 사원 values(2001,'이순신',10,'부장','125-365','서울 용산구','02-985-1254',3500,100,'1980-12-01','남자',null);
insert into 사원 values(2002,'홍길동',10,'대리','354-865','서울 강남구','02-865-1254',4000,'','2000-01-25','남자',2004);
insert into 사원 values(2003,'성유리',20,'사원','587-456','부산 해운대구','051-256-9874',2500,100,'2002-05-24','여자',2002);
insert into 사원 values(2004,'옥주현',30,'과장','987-452','서울 강남구','02-33-6589',5000,'','1997-03-22','여자',2001);
insert into 사원 values(2005,'길건',10,'대리','123-322','서울 성동구','02-888-9564',3000,100,'1999-07-15','여자',2004);
insert into 사원 values(2006,'한지혜',20,'사원','154-762','서울 송파구','02-3369-9874',2000,'','2003-05-22','여자',2005);
insert into 사원 values(2007,'박솔미',30,'대리','367-985','서울 영등포구','02-451-2563',3000,100,'2006-01-25','여자',2004);
insert into 사원 values(2008,'이효리',40,'사원','552-126','서울 중구','02-447-3256',2000,'','2001-02-02','여자',2007);

select * from 사원;
DESC 사원; --사원 테이블의 자료형이 나옴
commit;

-----------------------------------------이게 PL SQL이다.

DECLARE --이름없는 PROCEDURE
TYPE FIRSTTYPE IS RECORD
--(A VARCHAR2, B VARCHAR2, C NUMBER); -- 이렇게 써도 되지만 
(A 사원.사원명%TYPE,B 사원.직급%TYPE, C 사원.급여%TYPE); -- 좀더 쉽게 쓸수 있다 

CUS FIRSTTYPE;--CUS라는 변수를 선언하고 FORSTTYPE를 CUS에 넣는다 

BEGIN --문으로 시작하고 
SELECT 사원명,직급,급여 INTO CUS FROM 사원 WHERE 사원번호=2001;--사원명 직급 급여 INTO해서 CUS에 넣는다 

DBMS_OUTPUT.PUT_LINE('--------------------------');
DBMS_OUTPUT.PUT_LINE('사원명 직급 급여');
DBMS_OUTPUT.PUT_LINE(CUS.A||'  '||CUS.B||'  '||TO_CHAR(CUS.C));--급여가 숫자라서 문자로 변형
DBMS_OUTPUT.PUT_LINE('현재 질의한 계정은 '||USER||'입니다'); --USER는 시스템 변수
DBMS_OUTPUT.PUT_LINE('현재 질의한 시간은 '||TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MM:SS'));--SYDATE를 읽어와서 내가 원하는 입맛으로 표현한다 
END;--끝난다
--------------------------------------------------------------------------------------------------
DECLARE
SAWON_RECORD 사원%ROWTYPE; --테이블의 모든 컬럼을 쓸때 ROWTYPE 씀
BEGIN
SELECT * INTO SAWON_RECORD FROM 사원 WHERE 사원번호=2002;
DBMS_OUTPUT.PUT_LINE('사원번호: '|| SAWON_RECORD.사원번호);
DBMS_OUTPUT.PUT_LINE('사원명: '|| SAWON_RECORD.사원명);
DBMS_OUTPUT.PUT_LINE('직급: '|| SAWON_RECORD.직급);
DBMS_OUTPUT.PUT_LINE('주소: '|| SAWON_RECORD.주소);
DBMS_OUTPUT.PUT_LINE('입사일: '|| SAWON_RECORD.입사일);
END;


DECLARE
TYPE SANAME_TYPE IS TABLE OF 사원.사원명%TYPE
INDEX BY BINARY_INTEGER;

TYPE JIK_TYPE IS TABLE OF 사원.직급%TYPE
INDEX BY BINARY_INTEGER;

SANAME_COL SANAME_TYPE;--타입을 콜럼에 넣겟다
JIK_COL JIK_TYPE;

I BINARY_INTEGER := 0;
 
BEGIN

--K는 변수
FOR K IN (SELECT 사원명, 직급 FROM 사원) LOOP
I := I + 1;
SANAME_COL(I) := K.사원명;
JIK_COL(I) := k.직급;
END LOOP;

DBMS_OUTPUT.PUT_LINE('사원명 직급');
DBMS_OUTPUT.PUT_LINE('-----------');

FOR J IN 1..I LOOP--1부터 I까지
DBMS_OUTPUT.PUT_LINE(RPAD(SANAME_COL(J), 12) || RPAD(JIK_COL(J), 9));
END LOOP;

END;--BEGIN의 END
--DECLARE는 한번 실행하면 사라지기 때문에 따로 파일로 저장해두고 필요시에 복사해 사용한다

-------------------------------------------------------------------------------------------

--저장 PROCEDURE

CREATE OR REPLACE PROCEDURE CHANGE_PAY
(V_SANO IN NUMBER, V_NEW_PAY IN NUMBER)
IS 
BEGIN
UPDATE 사원 SET 급여 = V_NEW_PAY WHERE 사원번호 = V_SANO; --EXEC CHANGE_PAY(2001, 5000);
COMMIT;
END CHANGE_PAY;

--PROCEDURE의 이름을 쓰거나 안써도된다.

--IS 위에 쓰는 변수는 매개변수.
--IS 아래 쓰는 변수는 내부에서 사용하는 변수.지역변수.
--IN :외부에서 받아내는 값을 의미. 생략가능.매개변수
--OUT :외부로 내보내주는 값.

EXEC CHANGE_PAY(2001, 5000); --UPDATE이므로 한번 실행하고 끝.
EXEC CHANGE_PAY(2002, 3000);

-------함수 만들기
CREATE OR REPLACE FUNCTION F_TAX
(V_SANO IN NUMBER)
RETURN NUMBER
IS
V_TAX NUMBER;
BEGIN
SELECT ((급여*12) + NVL(커미션, 0))*0.05 INTO V_TAX
FROM 사원 WHERE 사원번호 = V_SANO;

RETURN V_TAX;
END F_TAX;
--------------------------------------------------------------------------------------------------
SELECT * FROM 사원;

SELECT 사원번호,사원명,직급,급여,커미션,F_TAX(2001) TAX FROM 사원 -- 함수부분 CMD캡처한걸 여기서 실행
WHERE 사원번호=2001;

--지금부터하는 코딩은  SCRIPT(파일)로 저장한다
ACCEPT ID PROMPT '검색할 아이디를 입력하세요: ';--ID는 사용자정의 변수

DECLARE

TYPE GOGAK IS RECORD --GOGAK이라는 데이터타입(RECORD)를 만듬
(A CUSTOM.USERID%TYPE, --A라는 변수를 만들고 
B CUSTOM.USERNAME%TYPE,
C NUMBER(12,2),
D NUMBER(5));

CUS GOGAK;

BEGIN
SELECT C.USERID, C.USERNAME, S.합계, S.구입횟수 INTO CUS
FROM CUSTOM C, --CUSTOM를 C라 하고
(SELECT USERID, SUM(PRICE) 합계, COUNT(*) 구입횟수
FROM SALES
GROUP BY USERID) S --이 괄호를 S로 만듬
WHERE C.USERID = S.USERID AND C.USERID ='&ID';--ACCEPT ID PROMPT 위의 ID값을 가져옴

DBMS_OUTPUT.PUT_LINE('아이디: '||CUS.A);
DBMS_OUTPUT.PUT_LINE('이  름: '||CUS.B);
DBMS_OUTPUT.PUT_LINE('판매액: '||CUS.C);
DBMS_OUTPUT.PUT_LINE('금  액: '||CUS.D);

END;

SELECT * FROM CUSTOM;


--직책을 입력 받아 그 직책의 급여의 총액,평균월급,인원수를 찾으시오

CREATE OR REPLACE PROCEDURE SEARCHJIK
(JIK IN VARCHAR2)
IS --IS를 기준으로 아래는 블럭 안에서 사용할 변수
A NUMBER;=0;
B NUMBER(12,2);=0; --여긴 자릿값을 줬음
C NUMBER:=0;
BEGIN
SELECT SUM(PAY),AVG(PAY),COUNT(*) INTO A,B,C
FROM COMPANY WHERE POSIT=JIK;

DMBS_OUTPUT.PUT.LINE('급여총액: '||A||'원');
DMBS_OUTPUT.PUT.LINE('평균월급: '||B||'원');
DMBS_OUTPUT.PUT.LINE('인원수: '||C||'명');
END SEARCHJIK; --END뒤에 SEARCHJIK생략가능
---------------------------------------------------------------

SELECT * FROM COMPANY;

SELECT SUM(PAY),ROUND(AVG(PAY)),COUNT(*)
FROM COMPANY WHERE POSIT=JIK;
GROUP BY POSIT;





--CUSTOM 테이블에 INSERT 시키는 프로시저(CUS_IN)
CREATE OR REPLACE PROCEDURE CUS_IN;
(A CUSTOM.USERID%TYPE, B CUSTOM.USERNAME%TYPE, C CUSTOM.JUMIN%TYPE,
 D CUSTOM.AGE%TYPE, E CUSTOM.SEX%TYPE, F CUSTOM.ZIP%TYPE, G CUSTOM.ADDR1%TYPE,
 H CUSTOM.ADDR2%TYPE, I CUSTOM.ADDR3%TYPE, J CUSTOM.TEL%TYPE, K CUSTOM.JOB%TYPE,
 L CUSTOM.SCHOL%TYPE, M CUSTOM.POINT%TYPE, N CUSTOM.REGDATE%TYPE)
IS
BEGIN
INSERT INTO CUSTOM VALUES (A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;
------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE CUS_IN
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,F VARCHAR2,G VARCHAR2,
H VARCHAR2,I VARCHAR2,J VARCHAR2,K VARCHAR2,L VARCHAR2,M NUMBER,N DATE)
IS 
BEGIN 
INSERT INTO CUSTOM VALUES(A,B,C,D,E,F,G,H,I,J,K,L,M,N);
COMMIT;
END;

EXEC CUS_IN('A002', 'INNA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);
EXEC CUS_IN('A001', 'SUZI', '123', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);

--CUSTOM 테이블에 UPDATE 시키는 프로시저(CUS_UP)
CREATE OR REPLACE PROCEDURE CUS_UP
(A VARCHAR2,B VARCHAR2,C VARCHAR2,D NUMBER,E VARCHAR2,
F VARCHAR2,G VARCHAR2,H VARCHAR2,I VARCHAR2,J VARCHAR2,
K VARCHAR2,L VARCHAR2,M NUMBER,N DATE,)
IS
BEGIN
UPDATE CUSTOM SET USERNAME=B, JUMIN=C, AGE=D, SEX=E,
ZIP=F, ADDR1=G, ADDR2=H, ADDR3=I, TEL=J, JOB=K, SCHOL=L,
POINT=M, REGDATE=N
WHERE USERID=A;
COMMIT;
END;

EXEC CUS_UP('A001', 'YUNA', '222', 27, '0', '123-123','서울','강남구', '역삼동', '010-1234-5678', '가수', '대졸', 123, SYSDATE);

--CUSTOM 테이블에 DELETE 시키는 프로시져(CUS_DEL)
CREATE OR REPLACE PROCEDURE CUS_DEL
(A VARCHAR2)
IS 
BEGIN 
DELETE CUSTOM WHERE USERID = A;
COMMIT;
END;

EXEC CUS_DEL('A001');


---함수
SELECT * FROM CUSTOM WHERE USERID = 'A001';

CREATE OR REPLACE FUNCTION F_COBVOL
(GILI IN NUMBER, POK IN NUMBER, NOPI IN NUMBER)
RETURN NUMBER
IS
BUPI NUMBER;
BEGIN
BUPI := GILI*POK*NOPI;
RETURN BUPI;
END;

SELECT F_COBVOL(4, 7, 8) FROM DUAL;

CREATE OR REPLACE FUNCTION F_NAME
(A IN VARCHAR2)
RETURN VARCHAR2
IS
B VARCHAR2(8);
BEGIN
B := SUBSTR(A, -2);
RETURN B;
END;

SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

COL NAME FORMAT A10;
SELECT USERNAME, F_NAME(USERNAME) NAME FROM CUSTOM WHERE ADDR1 = '제주도';

--SELECT 하는 순간에 폭을 맞춰준다


--사용자에게 입력받아서 출력하기
--입사일(REGDATE)를 입력받아 사원명, 입사일, 근무기간(6년 2RODNJF)을 출력

SELECT
FLOOR(MONTHS_BETWEEN(SYSDATE, '1994-10-10')/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, '1994-10-10'), 12)) || '개월'
FROM DUAL;

CREATE OR REPLACE FUNCTION F_SDAY
(V_DATE IN DATE)
RETURN VARCHAR2
IS
GUNDATE VARCHAR2(20);
BEGIN
GUNDATE :=
FLOOR(MONTHS_BETWEEN(SYSDATE, V_DATE)/12) || '년' ||
FLOOR(MOD(MONTHS_BETWEEN(SYSDATE, V_DATE), 12)) || '개월';
RETURN GUNDATE;
END;

COL GUNDATE FORMAT A10;
SELECT USERNAME, REGDATE, F_SDAY(REGDATE) GUNDATE FROM CUSTOM
WHERE ADDR1 = '제주도';


--주민번호를 입력시 성별 변환 해주는 함수
CREATE OR REPLACE FUNCTION F_GENDER
(V_JUMIN IN VARCHAR2)
RETURN VARCHAR2
IS
GENDER VARCHAR2(4);
BEGIN
GENDER := SUBSTR(V_JUMIN, 8, 1);


--IN 뒤에 SELECT 또는 직접 문자가 올 수도 있음
IF GENDER IN ('1', '3') THEN
 GENDER := '남';
ELSE
 GENDER := '여';

END IF;
 RETURN GENDER;
END;

COL GENDER FORMAT A10;
SELECT USERNAME, JUMIN, F_GENDER(JUMIN) GENDER
FROM CUSTOM WHERE  ADDR1 = '제주도';


--날짜에 년수, 개월수, 날수를 매개변수로 더하는 함수(EX.계약기간)

CREATE OR REPLACE FUNCTION F_GAEYAK
(V_DATE IN DATE, Y IN NUMBER, M IN NUMBER, D IN NUMBER)
RETURN DATE
IS
NALZA DATE;
BEGIN
NALZA := ADD_MONTHS(V_DATE, Y*12);
NALZA := ADD_MONTHS(NALZA, M);
NALZA := NALZA + D;
RETURN NALZA;
END;

SELECT USERNAME, REGDATE, F_GAEYAK(REGDATE, 1, 11, 29) GAEYAK
FROM CUSTOM WHERE ADDR1 = '제주도';


--몇번째에 오류나는지 확인할때는 CMD에서 SHOW ERRORS

SELECT * FROM CUSTOM;
DESC CUSTOM;



--IF
CREATE OR REPLACE FUNCTION F_PAYGRADE
(V_PAY IN NUMBER)
RETURN VARCHAR2
IS
RESULT VARCHAR2(20);
BEGIN
IF V_PAY > 2500000 THEN
 RESULT := 'A';
ELSIF V_PAY > 2000000 THEN
 RESULT := 'B';
ELSIF V_PAY > 1500000 THEN
 RESULT := 'C';
ELSIF V_PAY > 1000000 THEN
 RESULT := 'D';
ELSE
 RESULT := 'F';
END IF;
 RETURN RESULT;
END;

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'XA9776';

COL PAYGRADE FORMAT A10;
SELECT USERID, POSIT, PAY, F_PAYGRADE(PAY) || '등급' PAYGRADE
FROM COMPANY WHERE USERID = 'ye8802';

SELECT * FROM COMPANY;



--LOOP--자바에서 DO~WHLE문과 같아

CREATE TABLE LOOP1
(NO NUMBER, NAME VARCHAR2(9) DEFAULT '홍길동');

DECLARE
V_COUNT NUMBER(2) := 1;
BEGIN
LOOP
INSERT INTO LOOP1 (NO) VALUES(V_COUNT);
V_COUNT := V_COUNT + 1;
EXIT WHEN V_COUNT > 10;--빠져나와라~~
END LOOP;
DBMS_OUTPUT.PUT_LINE('데이터 입력 완료!!');
END;

SELECT* FROM LOOP1;



--FOR문
CREATE OR REPLACE PROCEDURE P_FOR
IS
BEGIN
FOR I IN 21..30 LOOP
INSERT INTO LOOP1 (NO) VALUES(I);
COMMIT;
END LOOP;
END;

EXEC P_FOR
SELECT * FROM LOOP1;



--WHILE문
CREATE OR REPLACE PROCEDURE BANBOK
(V_LOWER NUMBER, V_UPPER NUMBER) --IN생략
IS
V_COUNTER NUMBER(10) := 0;
V_OUTPUT NUMBER(10) := 0;
BEGIN
V_OUTPUT := V_LOWER;

WHILE V_OUTPUT < V_UPPER LOOP
V_COUNTER := V_COUNTER + 1;
V_OUTPUT := V_OUTPUT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE('최종값은 ' || TO_CHAR(V_OUTPUT) ||'이고'||
'총 반복 횟수는 ' || TO_CHAR(V_COUNTER) || '입니다');
END;

EXEC BANBOK(1, 10);



---DO~WHILE
CREATE OR REPLACE PROCEDURE P_CALC1
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
EXIT WHEN CNT > V_END;
END LOOP;
DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');


--DBMS_OUTPUT.PUT_LINE(V_START ||'부터'|| V_END ||
--'까지의 합은 ' ||TOT|| '입니다');
END;

EXEC P_CALC1(1, 100);



--WHILE
CREATE OR REPLACE PROCEDURE P_CALC2
(V_START NUMBER, V_END NUMBER)
IS
CNT NUMBER := V_START;
TOT NUMBER := 0;
BEGIN
WHILE CNT <= V_END LOOP
TOT := TOT + CNT;
CNT := CNT + 1;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC2(1, 100);



--FOR
CREATE OR REPLACE PROCEDURE P_CALC3
(V_START NUMBER, V_END NUMBER)
IS

TOT NUMBER := 0;
BEGIN
FOR I IN V_START..V_END LOOP
TOT := TOT + I;
END LOOP;

DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_START) ||'부터'|| TO_CHAR(V_END) ||
'까지의 합은 ' ||TO_CHAR(TOT)|| '입니다');
END;

EXEC P_CALC3(1, 100);



--예외처리
CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원;
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;

EXEC EXE_TEST;

CREATE OR REPLACE PROCEDURE EXE_TEST
IS
SW_REC 사원%ROWTYPE;
BEGIN
SELECT * INTO SW_REC FROM 사원 WHERE 사원번호 = '2000';
DBMS_OUTPUT.PUT_LINE('데이터 검색 성공!!');
EXCEPTION
WHEN TOO_MANY_ROWS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 많습니다!');

WHEN NO_DATA_FOUND THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('데이터가 없습니다!');

WHEN OTHERS THEN
ROLLBACK;
DBMS_OUTPUT.PUT_LINE('기타 오류입니다!');

END;











